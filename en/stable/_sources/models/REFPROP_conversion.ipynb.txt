{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "4d8d718f",
   "metadata": {},
   "source": [
    "## REFPROP <10.0 conversion\n",
    "\n",
    "As of ``teqp`` version 0.19.0, it is possible to read in the .FLD and HMX.BNC of [NIST REFPROP 10.0](https://www.nist.gov/srd/refprop) and load them into ``teqp`` multifluid models. There are two approaches; either you can pass paths to the files of interest, or you can load them into JSON once, and pass the converted JSON back into teqp's ``make_model`` function.\n",
    "\n",
    "The conversion code is uses that of [REFPROP-interop](https://github.com/ianhbell/REFPROP-interop) and the fluid file format of [CoolProp](https://github.com/coolprop/coolprop) is used.\n",
    "\n",
    "The example is based on the interaction parameters provided in the supporting information of the paper [Mixture Model for Refrigerant Pairs R-32/1234yf, R-32/1234ze(E), R-1234ze(E)/227ea, R-1234yf/152a, and R-125/1234yf](https://doi.org/10.1063/5.0135368) by Ian Bell"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "38951d36",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-03-15T22:41:09.300240Z",
     "iopub.status.busy": "2024-03-15T22:41:09.300079Z",
     "iopub.status.idle": "2024-03-15T22:41:09.313949Z",
     "shell.execute_reply": "2024-03-15T22:41:09.313431Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'0.19.1'"
      ]
     },
     "execution_count": 1,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import json\n",
    "import teqp\n",
    "teqp.__version__"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "f2c9865b",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-03-15T22:41:09.315978Z",
     "iopub.status.busy": "2024-03-15T22:41:09.315672Z",
     "iopub.status.idle": "2024-03-15T22:41:09.364806Z",
     "shell.execute_reply": "2024-03-15T22:41:09.364209Z"
    }
   },
   "outputs": [],
   "source": [
    "# The first approach, we just pass paths to the files, they live in the folder \n",
    "# containing this notebook, and teqp does the conversion on the fly\n",
    "jsimple = {\n",
    "    'kind': 'multifluid',\n",
    "    'model': {\n",
    "        'HMX.BNC': 'HMX.BNC',\n",
    "        'components': ['R152A.FLD', 'NEWR1234YF.FLD'],\n",
    "    }\n",
    "}\n",
    "model = teqp.make_model(jsimple)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "2ec3c0ba",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-03-15T22:41:09.366932Z",
     "iopub.status.busy": "2024-03-15T22:41:09.366627Z",
     "iopub.status.idle": "2024-03-15T22:41:13.084013Z",
     "shell.execute_reply": "2024-03-15T22:41:13.083464Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "45.8 ms ± 89.5 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n"
     ]
    }
   ],
   "source": [
    "%timeit teqp.make_model(jsimple)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "67df32fe",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-03-15T22:41:13.086025Z",
     "iopub.status.busy": "2024-03-15T22:41:13.085855Z",
     "iopub.status.idle": "2024-03-15T22:41:13.135200Z",
     "shell.execute_reply": "2024-03-15T22:41:13.134757Z"
    }
   },
   "outputs": [],
   "source": [
    "# Convert each of the FLD files to JSON\n",
    "FLD0 = teqp.convert_FLD('R152A.FLD', name='R152A')\n",
    "FLD1 = teqp.convert_FLD('NEWR1234YF.FLD', name='R1234YF')\n",
    "BIP, DEP = teqp.convert_HMXBNC('HMX.BNC')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "080804cc",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-03-15T22:41:13.137315Z",
     "iopub.status.busy": "2024-03-15T22:41:13.137006Z",
     "iopub.status.idle": "2024-03-15T22:41:13.140391Z",
     "shell.execute_reply": "2024-03-15T22:41:13.140010Z"
    }
   },
   "outputs": [],
   "source": [
    "jconverted = {\n",
    "    \"kind\": \"multifluid\",\n",
    "    \"model\": {\n",
    "        \"components\": [FLD0, FLD1],\n",
    "        \"BIP\": BIP,\n",
    "        \"departure\": DEP\n",
    "    }\n",
    "}\n",
    "model = teqp.make_model(jconverted)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "cce51d45",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-03-15T22:41:13.142179Z",
     "iopub.status.busy": "2024-03-15T22:41:13.142017Z",
     "iopub.status.idle": "2024-03-15T22:41:18.201422Z",
     "shell.execute_reply": "2024-03-15T22:41:18.200898Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "608 µs ± 2.55 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)\n"
     ]
    }
   ],
   "source": [
    "%timeit teqp.make_model(jconverted)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f4f6c961",
   "metadata": {},
   "source": [
    "From this example you can note that the first method is a lot slower because the FLD->JSON conversion needs to happen for each call, while in the second method it is much faster because only the JSON parsing needs to be done in ``teqp``."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "c77b1880",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-03-15T22:41:18.203340Z",
     "iopub.status.busy": "2024-03-15T22:41:18.203178Z",
     "iopub.status.idle": "2024-03-15T22:41:18.247819Z",
     "shell.execute_reply": "2024-03-15T22:41:18.247376Z"
    }
   },
   "outputs": [],
   "source": [
    "# It is also possible to prefix the path to indicate that the \n",
    "# indicated file (after the FLD::) should be converted from REFPROP format\n",
    "jconverted = {\n",
    "    \"kind\": \"multifluid\",\n",
    "    \"model\": {\n",
    "        \"components\": [\"FLDPATH::R152A.FLD\", 'FLDPATH::NEWR1234YF.FLD'],\n",
    "        \"BIP\": BIP,\n",
    "        \"departure\": DEP\n",
    "    }\n",
    "}\n",
    "model = teqp.make_model(jconverted)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "341ac9df",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-03-15T22:41:18.249800Z",
     "iopub.status.busy": "2024-03-15T22:41:18.249486Z",
     "iopub.status.idle": "2024-03-15T22:41:21.609797Z",
     "shell.execute_reply": "2024-03-15T22:41:21.609262Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "41.4 ms ± 98.1 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n"
     ]
    }
   ],
   "source": [
    "%timeit teqp.make_model(jconverted)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
