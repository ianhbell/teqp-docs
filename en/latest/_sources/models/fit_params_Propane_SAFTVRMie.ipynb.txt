{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "7282e5c5",
   "metadata": {},
   "source": [
    "# Fitting pure fluid model parameters\n",
    "\n",
    "The cost function to be minimized is formed of a number of contributions:\n",
    "\n",
    "* SatRhoLPoint: Saturated liquid density\n",
    "* SatRhoLPPoint: Saturated liquid density and vapor pressure are combined into one contribution\n",
    "* SatRhoLPWPoint: Saturated liquid density, vapor pressure, and speed of sound are combined into one contribution\n",
    "* SOSPoint: Speed of sound for homogeneous state\n",
    "\n",
    "Instances of these models are added to the ``PureParameterOptimizer`` instance via the ``add_one_contribution`` method.  The cost function is evaluated via either the ``cost_function`` method or the ``cost_function_threaded`` (the latter is threaded and you need to specify how many threads should be used as the second argument).\n",
    "\n",
    "What optimization algorithm you want to use is up to you. I used differential evolution in the example here because it is available in scipy.optimize."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "0a680ef2",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-12-12T18:09:34.427867Z",
     "iopub.status.busy": "2024-12-12T18:09:34.427456Z",
     "iopub.status.idle": "2024-12-12T18:09:34.928137Z",
     "shell.execute_reply": "2024-12-12T18:09:34.927681Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'0.22.0'"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "import teqp\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import CoolProp.CoolProp as CP\n",
    "import scipy.optimize\n",
    "display(teqp.__version__)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "1e80592f",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-12-12T18:09:34.929958Z",
     "iopub.status.busy": "2024-12-12T18:09:34.929585Z",
     "iopub.status.idle": "2024-12-12T18:09:34.933399Z",
     "shell.execute_reply": "2024-12-12T18:09:34.932983Z"
    }
   },
   "outputs": [],
   "source": [
    "nonpolar = {\n",
    "    \"kind\": \"SAFT-VR-Mie\",\n",
    "    \"model\": {\n",
    "        \"coeffs\": [\n",
    "        {\n",
    "          \"name\": \"R32\",\n",
    "          \"BibTeXKey\": \"Bell\",\n",
    "          \"m\": 1.2476268271391935,\n",
    "          \"sigma_m\": 3.6080717234117107e-10,\n",
    "          \"epsilon_over_k\": 172.53065054286867,\n",
    "          \"lambda_r\": 14.634722358167384,\n",
    "          \"lambda_a\": 6\n",
    "        }\n",
    "      ]\n",
    "    }\n",
    "}\n",
    "\n",
    "template = {  \n",
    "  'kind': 'genericSAFT', \n",
    "  'model': {\n",
    "      'nonpolar': nonpolar\n",
    "  }\n",
    "}\n",
    "\n",
    "# These are the JSON pointers for the locations in the JSON where the fitted parameters should be inserted\n",
    "# NOTE: '/' inside field names MUST be escaped as ~1; see https://datatracker.ietf.org/doc/html/rfc6901#section-3\n",
    "pointers = [\n",
    "    '/model/nonpolar/model/coeffs/0/m',\n",
    "    '/model/nonpolar/model/coeffs/0/sigma_m',\n",
    "    '/model/nonpolar/model/coeffs/0/epsilon_over_k',\n",
    "    '/model/nonpolar/model/coeffs/0/lambda_r',\n",
    "    '/model/nonpolar/model/coeffs/0/lambda_a'\n",
    "]\n",
    "x0 = [1.5, 3e-10, 150, 19, 5.7]\n",
    "bounds = [(1,5),(2e-10,5e-10),(100,400),(8,25),(5.1, 7.0)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "6942857a",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-12-12T18:09:34.934956Z",
     "iopub.status.busy": "2024-12-12T18:09:34.934651Z",
     "iopub.status.idle": "2024-12-12T18:09:35.134742Z",
     "shell.execute_reply": "2024-12-12T18:09:35.134257Z"
    }
   },
   "outputs": [
    {
     "ename": "AttributeError",
     "evalue": "module 'teqp' has no attribute 'paramopt'",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mAttributeError\u001b[0m                            Traceback (most recent call last)",
      "Cell \u001b[0;32mIn[3], line 2\u001b[0m\n\u001b[1;32m      1\u001b[0m FLD \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mPropane\u001b[39m\u001b[38;5;124m'\u001b[39m\n\u001b[0;32m----> 2\u001b[0m ppo \u001b[38;5;241m=\u001b[39m \u001b[43mteqp\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mparamopt\u001b[49m\u001b[38;5;241m.\u001b[39mPureParameterOptimizer(template, pointers)\n\u001b[1;32m      4\u001b[0m Ts \u001b[38;5;241m=\u001b[39m np\u001b[38;5;241m.\u001b[39mlinspace(\u001b[38;5;241m230\u001b[39m, \u001b[38;5;241m330\u001b[39m)\n\u001b[1;32m      5\u001b[0m \u001b[38;5;28;01mfor\u001b[39;00m T \u001b[38;5;129;01min\u001b[39;00m Ts:\n",
      "\u001b[0;31mAttributeError\u001b[0m: module 'teqp' has no attribute 'paramopt'"
     ]
    }
   ],
   "source": [
    "FLD = 'Propane'\n",
    "ppo = teqp.paramopt.PureParameterOptimizer(template, pointers)\n",
    "\n",
    "Ts = np.linspace(230, 330)\n",
    "for T in Ts:\n",
    "    pt = teqp.paramopt.SatRhoLPPoint()\n",
    "    rhoL, rhoV = [CP.PropsSI('Dmolar','Q',Q,'T',T,FLD) for Q in [0,1]]\n",
    "    p = CP.PropsSI('P','Q',0,'T',T,FLD)\n",
    "    pt.T = T\n",
    "    # Measurands (here, pseudo-experimental values coming from the reference EOS)\n",
    "    pt.p_exp = p\n",
    "    pt.rhoL_exp = rhoL\n",
    "    # Control parameters\n",
    "    pt.rhoL_guess = rhoL\n",
    "    pt.rhoV_guess = rhoV\n",
    "    pt.weight_p = 100\n",
    "    pt.weight_rho = 100\n",
    "    ppo.add_one_contribution(pt)\n",
    "    \n",
    "def cost_function(x):\n",
    "    return ppo.cost_function_threaded(x, 4)\n",
    "print(cost_function(x0))\n",
    "\n",
    "r = scipy.optimize.differential_evolution(cost_function, bounds=bounds, disp=True, maxiter=10000)\n",
    "print(r)\n",
    "x = r.x\n",
    "model = teqp.make_model(ppo.build_JSON(x))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "f5463428",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-12-12T18:09:35.136494Z",
     "iopub.status.busy": "2024-12-12T18:09:35.136172Z",
     "iopub.status.idle": "2024-12-12T18:09:35.155857Z",
     "shell.execute_reply": "2024-12-12T18:09:35.155384Z"
    }
   },
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'model' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[0;32mIn[4], line 2\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[38;5;66;03m# Plot the rho-T data\u001b[39;00m\n\u001b[0;32m----> 2\u001b[0m Tc, rhoc \u001b[38;5;241m=\u001b[39m \u001b[43mmodel\u001b[49m\u001b[38;5;241m.\u001b[39msolve_pure_critical(\u001b[38;5;241m400\u001b[39m, \u001b[38;5;241m5000\u001b[39m)\n\u001b[1;32m      3\u001b[0m \u001b[38;5;66;03m# print(Tc, rhoc)\u001b[39;00m\n\u001b[1;32m      4\u001b[0m anc \u001b[38;5;241m=\u001b[39m teqp\u001b[38;5;241m.\u001b[39mbuild_ancillaries(model, Tc, rhoc, \u001b[38;5;241m0.5\u001b[39m\u001b[38;5;241m*\u001b[39mTc)\n",
      "\u001b[0;31mNameError\u001b[0m: name 'model' is not defined"
     ]
    }
   ],
   "source": [
    "# Plot the rho-T data\n",
    "Tc, rhoc = model.solve_pure_critical(400, 5000)\n",
    "# print(Tc, rhoc)\n",
    "anc = teqp.build_ancillaries(model, Tc, rhoc, 0.5*Tc)\n",
    "RHOL, RHOV, PPP = [],[],[]\n",
    "z = np.array([1.0])\n",
    "Tsverify = np.linspace(230, Tc*0.9, 1000)\n",
    "for T in Tsverify:\n",
    "    rhoL, rhoV = model.pure_VLE_T(T, anc.rhoL(T), anc.rhoV(T), 10)\n",
    "    p = rhoL*model.get_R(z)*T*(1+model.get_Ar01(T, rhoL, z))\n",
    "    RHOL.append(rhoL)\n",
    "    RHOV.append(rhoV)\n",
    "    PPP.append(p)\n",
    "    \n",
    "# Plot deviation plots in the fitted data\n",
    "line, = plt.plot(np.array(RHOL), Tsverify)\n",
    "plt.plot(np.array(RHOV), Tsverify, color=line.get_color())\n",
    "for Q in [0, 1]:\n",
    "    D = CP.PropsSI('Dmolar','T',Tsverify,'Q',Q,FLD)\n",
    "    plt.plot(D, Tsverify, lw=2, color='k')\n",
    "plt.gca().set(xlabel=r'$\\rho$ / mol/m$^3$', ylabel='$T$ / K')\n",
    "\n",
    "fig, (ax1, ax2) = plt.subplots(2,1, figsize=(10,7), sharex=True)\n",
    "\n",
    "ax1.plot(Tsverify, (np.array(PPP)/CP.PropsSI('P','T',Tsverify,'Q',0,FLD)-1)*100)\n",
    "ax1.set(ylabel=r'$(p_{fit}/p_{\\rm pexp}-1)\\times 100$')\n",
    "\n",
    "ax2.plot(Tsverify, (np.array(RHOL)/CP.PropsSI('Dmolar','T',Tsverify,'Q',0,FLD)-1)*100, label='liquid')\n",
    "ax2.plot(Tsverify, (np.array(RHOV)/CP.PropsSI('Dmolar','T',Tsverify,'Q',1,FLD)-1)*100, label='vapor')\n",
    "ax2.legend()\n",
    "ax2.set(ylabel=r'$(\\rho_{fit}/\\rho_{\\rm pexp}-1)\\times 100$', xlabel='$T$ / K');"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
